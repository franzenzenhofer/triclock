<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <title>TRICHRONO — show.franzai.com version (SAVED FOR ANALYSIS)</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #0b0b12;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }
    canvas { display: block; }
  </style>
</head>
<body>
  <canvas id="c"></canvas>

  <script>
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');
    let W, H, cx, cy, size;

    function resize() {
      W = canvas.width = window.innerWidth;
      H = canvas.height = window.innerHeight;
      cx = W / 2;
      cy = H / 2;
      size = Math.min(W, H) * 0.42;
    }
    resize();
    window.addEventListener('resize', resize);

    function getTriangle() {
      const topY = cy - size;
      const botY = cy + size * 0.58;
      const halfBase = size * 0.95;
      return {
        A: { x: cx, y: topY },
        B: { x: cx - halfBase, y: botY },
        C: { x: cx + halfBase, y: botY },
      };
    }

    function lerp(a, b, t) { return { x: a.x + (b.x - a.x) * t, y: a.y + (b.y - a.y) * t }; }
    function dist(a, b) { return Math.hypot(b.x - a.x, b.y - a.y); }

    function drawLine(a, b, color, width, alpha = 1) {
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.strokeStyle = color;
      ctx.lineWidth = width;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(a.x, a.y);
      ctx.lineTo(b.x, b.y);
      ctx.stroke();
      ctx.restore();
    }

    function drawCircle(p, r, color, alpha = 1) {
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    function drawGlowCircle(p, r, color, glowR) {
      ctx.save();
      const grad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, glowR);
      grad.addColorStop(0, color);
      grad.addColorStop(0.3, color + '88');
      grad.addColorStop(1, color + '00');
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(p.x, p.y, glowR, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      drawCircle(p, r, color, 1);
      drawCircle(p, r * 0.5, '#fff', 0.7);
    }

    function drawText(text, x, y, font, color, alpha = 1) {
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.fillStyle = color;
      ctx.font = font;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(text, x, y);
      ctx.restore();
    }

    function drawScale(from, to, count, color, activeCount, majorEvery) {
      for (let i = 0; i <= count; i++) {
        const t = i / count;
        const p = lerp(from, to, t);
        const isMajor = i % majorEvery === 0;
        const isActive = i <= activeCount;

        const dx = to.x - from.x, dy = to.y - from.y;
        const len = Math.hypot(dx, dy);
        const nx = -dy / len, ny = dx / len;

        const tickLen = isMajor ? size * 0.035 : size * 0.018;
        const inner = { x: p.x + nx * 2, y: p.y + ny * 2 };
        const outer = { x: p.x + nx * (2 + tickLen), y: p.y + ny * (2 + tickLen) };

        drawLine(
          inner, outer,
          isActive ? color : '#444455',
          isMajor ? 2.5 : 1,
          isActive ? 0.9 : 0.2
        );

        if (isMajor && i > 0 && i < count) {
          const lp = { x: p.x + nx * (tickLen + 16), y: p.y + ny * (tickLen + 16) };
          drawText(
            i.toString(),
            lp.x, lp.y,
            `${Math.max(10, size * 0.04)}px 'Helvetica Neue', Arial, sans-serif`,
            isActive ? color : '#444455',
            isActive ? 0.7 : 0.25
          );
        }
      }
    }

    function drawEdgeProgress(from, to, progress, color) {
      const endP = lerp(from, to, progress);

      ctx.save();
      const grad = ctx.createLinearGradient(from.x, from.y, endP.x, endP.y);
      grad.addColorStop(0, color + '00');
      grad.addColorStop(0.7, color + '44');
      grad.addColorStop(1, color + 'aa');
      ctx.strokeStyle = grad;
      ctx.lineWidth = 6;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(from.x, from.y);
      ctx.lineTo(endP.x, endP.y);
      ctx.stroke();
      ctx.restore();

      drawLine(lerp(from, to, Math.max(0, progress - 0.03)), endP, color, 3, 0.9);
      return endP;
    }

    function hslToHex(h, s, l) {
      h = ((h % 360) + 360) % 360;
      s = Math.max(0, Math.min(100, s)) / 100;
      l = Math.max(0, Math.min(100, l)) / 100;

      const a = s * Math.min(l, 1 - l);
      const f = n => {
        const k = (n + h / 30) % 12;
        const c = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
        return Math.round(255 * c).toString(16).padStart(2, '0');
      };
      return `#${f(0)}${f(8)}${f(4)}`;
    }

    /*
      CLEAN 1:1 MAPPING — one time dimension per HSL channel:
      SECONDS → HUE    (0-360)
      MINUTES → SAT    (80%-100%)
      HOURS   → LIT    (~20%-70%)
    */
    function timeToColor(hours, minutes, seconds) {
      const hue = (seconds / 60) * 360;
      const sat = 80 + (minutes / 60) * 20;
      const lit = 45 + Math.sin((hours / 24) * Math.PI) * 25;
      return { hue, sat, lit };
    }

    function drawInnerTriangle(hTip, mTip, sTip, color) {
      const { hue, sat, lit } = color;

      const main = hslToHex(hue, sat, lit);
      const lighter = hslToHex(hue + 30, sat, lit + 10);
      const darker = hslToHex(hue - 30, sat, lit - 5);

      // Filled triangle
      ctx.save();
      ctx.beginPath();
      ctx.moveTo(hTip.x, hTip.y);
      ctx.lineTo(mTip.x, mTip.y);
      ctx.lineTo(sTip.x, sTip.y);
      ctx.closePath();
      ctx.fillStyle = main;
      ctx.globalAlpha = 0.85;
      ctx.fill();

      // Per-vertex tinting
      const rH = ctx.createRadialGradient(hTip.x, hTip.y, 0, hTip.x, hTip.y, size * 0.5);
      rH.addColorStop(0, lighter);
      rH.addColorStop(1, 'transparent');
      ctx.fillStyle = rH;
      ctx.globalAlpha = 0.25;
      ctx.fill();

      const rM = ctx.createRadialGradient(mTip.x, mTip.y, 0, mTip.x, mTip.y, size * 0.5);
      rM.addColorStop(0, darker);
      rM.addColorStop(1, 'transparent');
      ctx.fillStyle = rM;
      ctx.globalAlpha = 0.2;
      ctx.fill();

      // Border
      ctx.strokeStyle = hslToHex(hue, 100, Math.min(90, lit + 30));
      ctx.lineWidth = 2.5;
      ctx.globalAlpha = 0.9;
      ctx.stroke();
      ctx.restore();

      // Glow
      ctx.save();
      ctx.shadowColor = main;
      ctx.shadowBlur = 50;
      ctx.strokeStyle = main;
      ctx.lineWidth = 2;
      ctx.globalAlpha = 0.5;
      ctx.beginPath();
      ctx.moveTo(hTip.x, hTip.y);
      ctx.lineTo(mTip.x, mTip.y);
      ctx.lineTo(sTip.x, sTip.y);
      ctx.closePath();
      ctx.stroke();
      ctx.restore();
    }

    function frame() {
      ctx.clearRect(0, 0, W, H);

      const bgGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, size * 1.5);
      bgGrad.addColorStop(0, '#111120');
      bgGrad.addColorStop(1, '#0b0b12');
      ctx.fillStyle = bgGrad;
      ctx.fillRect(0, 0, W, H);

      const { A, B, C } = getTriangle();

      const now = new Date();
      const hours = now.getHours();
      const minutes = now.getMinutes();
      const seconds = now.getSeconds();
      const ms = now.getMilliseconds();

      const h = hours + minutes / 60 + seconds / 3600;
      const m = minutes + seconds / 60 + ms / 60000;
      const s = seconds + ms / 1000;

      // Frame + scales + progress
      drawLine(A, B, '#222230', 1.5, 0.3);
      drawLine(B, C, '#222230', 1.5, 0.3);
      drawLine(C, A, '#222230', 1.5, 0.3);

      drawScale(A, B, 24, '#ff3366', Math.floor(h), 6);
      drawScale(B, C, 60, '#00d4ff', Math.floor(m), 15);
      drawScale(C, A, 60, '#b8ff00', Math.floor(s), 15);

      const hTip = drawEdgeProgress(A, B, h / 24, '#ff3366');
      const mTip = drawEdgeProgress(B, C, m / 60, '#00d4ff');
      const sTip = drawEdgeProgress(C, A, s / 60, '#b8ff00');

      // Color triangle
      drawInnerTriangle(hTip, mTip, sTip, timeToColor(h, m, s));

      // Glowing tips
      drawGlowCircle(hTip, 6, '#ff3366', size * 0.08);
      drawGlowCircle(mTip, 5, '#00d4ff', size * 0.07);
      drawGlowCircle(sTip, 4, '#b8ff00', size * 0.06);

      drawCircle(A, 4, '#ff3366', 0.6);
      drawCircle(B, 4, '#00d4ff', 0.6);
      drawCircle(C, 4, '#b8ff00', 0.6);

      // Labels
      const lo = size * 0.12;

      const hMid = lerp(A, B, 0.5);
      const hn = -(B.y - A.y) / dist(A, B);
      const hny = (B.x - A.x) / dist(A, B);
      drawText(
        'HOURS → LUM',
        hMid.x + hn * lo,
        hMid.y + hny * lo,
        `300 ${Math.max(10, size * 0.038)}px 'Helvetica Neue', Arial, sans-serif`,
        '#ff3366',
        0.35
      );

      const mMid = lerp(B, C, 0.5);
      drawText(
        'MINUTES → SAT',
        mMid.x,
        mMid.y + lo * 0.7,
        `300 ${Math.max(10, size * 0.038)}px 'Helvetica Neue', Arial, sans-serif`,
        '#00d4ff',
        0.35
      );

      const sMid = lerp(C, A, 0.5);
      const sn = -(A.y - C.y) / dist(C, A);
      const sny = (A.x - C.x) / dist(C, A);
      drawText(
        'SECONDS → HUE',
        sMid.x + sn * lo,
        sMid.y + sny * lo,
        `300 ${Math.max(10, size * 0.038)}px 'Helvetica Neue', Arial, sans-serif`,
        '#b8ff00',
        0.35
      );

      // Subtle digital time
      const pad = n => n.toString().padStart(2, '0');
      drawText(
        `${pad(hours)}:${pad(minutes)}:${pad(seconds)}`,
        cx,
        cy + size * 0.28,
        `700 ${Math.max(14, size * 0.06)}px Georgia, 'Times New Roman', serif`,
        '#e0e0e8',
        0.13
      );

      requestAnimationFrame(frame);
    }

    frame();
  </script>
</body>
</html>
